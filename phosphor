#!/usr/bin/env perl
#
# Name       : phosphor
# Author     : Ren√© Uittenbogaard
# Version    : 0.93
# Description: animate text like on a slow phosphorescent CRT terminal
# Usage      : see manual
#

############################################################################
# version info for *roff

=pod

=for roff
.ds Yr 2020-2022
.ds Vw @(#) phosphor 0.93
.de Vp
This manual pertains to \fBphosphor\fP version \\$3.
..

=cut

############################################################################
# prerequisites

use strict;
use warnings;
#use diagnostics;
#use utf8;
use POSIX qw(fmin);
use IO::Handle;
use Getopt::Long;
use Time::HiRes qw(sleep);
use Term::Terminfo;
use Term::ANSIColor;

################################################################################
# declarations

my ($NORMAL, $SMUL, $RMUL, $BOLD, $REVERSE, $CNORM, $CIVIS);
my ($BLACK, $GREEN, $ON_BLACK, $ON_GREEN);
my $COLUMNS;

my %CASES = qw(
	l lower
	u upper
	n normal
	s underscore
	r reverse
);

@CASES{values %CASES} = values %CASES;

################################################################################
# functions

sub usage {
	my $error = shift;
	my @usage = <<"	_endUsage_";
Usage:
	phosphor [ -br | --blink-rate <delay> ] [ -bt | --blink-times <num> ]
		 [ { -c | --case } { lower | upper | normal | reverse | underscore } ]
		 [ -d | --delay <delay> ] [ --demo ] [ <filename> ]
	
	-br|--blink-rate  : cursor blink delay after interpunction, in seconds (default: 0.1s)
	-bt|--blink-times : number of times to blink the cursor after interpunction (default: 2)
	-d|--delay        : print delay between words, in seconds (default: 0.05s)
	-c|--case         : specify case conversion:
	                    l | lower      : to lowercase
	                    u | upper      : to uppercase (default)
	                    n | normal     : no case conversion
	                    r | reverse    : upper -> reverse; lower -> upper
	                    s | underscore : upper -> underscored; lower -> upper
	--demo            : use demo text (default: read text from stdin or <filename>)
	
	_endUsage_
	if ($error) {
		warn $error;
		die @usage;
	} else {
		print @usage;
	}
}

sub getopts {
	my $delay = 0.05;
    my $blink_rate = 0.1;
    my $blink_times = 2;
	my $case  = 'upper';
	my $demo;
	GetOptions(
		'blink-rate|br=f'  => \$blink_rate,
		'blink-times|bt=f' => \$blink_times,
		'delay|d=f'        => \$delay,
		'demo'             => \$demo,
		'case|c=s'         => \$case,
	) or usage("Error in command line arguments\n");
	if (!$CASES{$case}) {
		usage("Error: Unknown value for 'case': $case\n");
	}
	if ($delay =~ /[^\d.]/) {
		usage("Error: -d requires a real number\n");
	}
	return {
		blink_rate => $blink_rate,
		blink_times => $blink_times,
		delay => $delay,
		demo => $demo,
		case => $CASES{$case},
	};
}

sub interrupt_handler {
    # force the application to end through the END block when interrupted
    $SIG{INT} = sub { exit 1; };
}

sub resizer {
	$COLUMNS = `tput cols`;
	$SIG{WINCH} = *resizer;
}

sub init {
    my $ti = Term::Terminfo->new();

    $NORMAL   = $ti->getstr('sgr0' ); # || "\e[m";
    $SMUL     = $ti->getstr('smul' ); # || "\e[4m";
    $RMUL     = $ti->getstr('rmul' ); # || "\e[24m";
    $BOLD     = $ti->getstr('bold' ); # || "\e[1m";
    $REVERSE  = $ti->getstr('rev'  ); # || "\e[7m";
    $CNORM    = $ti->getstr('cnorm'); # || "\e[?12l\e[?25h";
    $CIVIS    = $ti->getstr('civis'); # || "\e[?25l";

    $BLACK    = color('black')      ; # || "\e[30m";
    $GREEN    = color('green')      ; # || "\e[32m";
    $ON_BLACK = color('on_black')   ; # || "\e[40m";
    $ON_GREEN = color('on_green')   ; # || "\e[42m";

    interrupt_handler();
	resizer();
}

sub underscorecase {
	my ($text) = @_;
	$text =~ s/(.)/
		$1 eq lc($1) ? uc($1) : "$SMUL$1$RMUL"
	/eg;
	return $text;
}

sub reversecase {
	my ($text) = @_;
	$text =~ s/(.)/
		$1 eq lc($1) ? uc($1) : "$BLACK$ON_GREEN$1$GREEN$ON_BLACK"
	/eg;
	return $text;
}

sub cased {
	my ($type, $text) = @_;
	return $type eq 'upper'
		? uc($text)
		: $type eq 'lower'
		? lc($text)
		: $type eq 'underscore'
		? underscorecase($text)
		: $type eq 'reverse'
		? reversecase($text)
		: $text;
}

sub flash {
	my $case = shift;
	my $leader = cased $case, shift;
	my $text = cased $case, shift;
	my $delay = shift;
    my $blink_rate = shift;
    my $blink_times = shift;

	print "\r$NORMAL$GREEN$ON_BLACK$leader$BOLD$text";
	sleep $delay;
	print "\r$NORMAL$GREEN$ON_BLACK$leader$text";
    my ($punct) = ($text =~ /([.,!?])\s+$/);
    if ($punct) {
        my $blinks = $punct ne ',' ? $blink_times : fmin($blink_times, 1);
        while ($blinks--) {
            sleep $blink_rate; print $CIVIS;
            sleep $blink_rate; print $CNORM;
        }
    }
}

sub flashtext {
    my ($leader, $text, $opts) = @_;
    flash $opts->{case}, $leader, $text, $opts->@{qw(delay blink_rate blink_times)};
}

sub munch {
}

sub phosphorize {
	my ($opts) = @_;
	local *SOURCE = $opts->{demo} ? *DATA : *ARGV;
	while (<SOURCE>) {
		s/\e\[([0-9]{1,2}(;[0-9]{1,2})*)?[m|K]//g; # remove color escapes
		s/[\r\n]//g; # remove CR and LF
		# print word by word
		my $line = '';
		while (/((.+?)(\s+|$))/g) {
			my ($match, $_text, $_space) = ($1, $2, $3);
			# if the matched text does not fit on the current screen line, advance to the next screen line
			if (length($line) + length($match) > $COLUMNS) {
				$line = '';
				print "\n";
			}
			# if the matched text is longer than one line, just chop it up
			while (length($match) > $COLUMNS) {
                flashtext '', substr($match, 0, $COLUMNS), $opts;
				print "\n";
				$match = substr($match, $COLUMNS);
			}
            flashtext $line, $match, $opts;
			$line .= $match;
		}
		print "\n";
	}
	close SOURCE;
}

sub autoflush (&) {
    my $sub = shift;
	STDOUT->autoflush(1);
    $sub->();
	STDOUT->autoflush(0);
}

sub main {
	my $opts = getopts();
    init();
    autoflush {
        phosphorize($opts);
    };
}

################################################################################
# main

main();

END {
	print $NORMAL, $CNORM;
}

################################################################################
# manual

=pod

=for section 6

=for roff
.de us \" underscore string
\\$1\l'|0\(ul'
..
.hy 0 \" hyphenation off


=head1 NAME

B<phosphor> - display text like on a phosphorescent CRT terminal

=head1 SYNOPSIS

=for roff
.ad l \" align left

B<phosphor>
S<< [ { B<-br> | B<--blink-rate> } I<delay> ] >>
S<< [ { B<-bt> | B<--blink-times> } I<num> ] >>
S<< [ { B<-c>| B<--case> } I<style> ] >>
S<< [ B<-d> | B<--delay> I<delay> ] >>
S<< [ B<--demo> ] [ I<filename> [ I<filename> ... ] ] >>

=for roff
.ad n \" align normal

=head1 DESCRIPTION

B<phosphor> displays text in a word-by-word animation as on a slow CRT terminal.
Words are flashed extra bright/bold when first displayed.
By default, the text is converted to uppercase.

Text can be read from files or from standard input.

=head1 OPTIONS

=over 4

=item B<-br> I<delay>, B<--blink-rate> I<delay>

The delay in (fractional) seconds between cursor blinks after interpunction (default: 0.1).

=item B<-bt> I<num>, B<--blink-times> I<num>

The number of times the cursor will blink after a full stop, question mark, or exclamation mark.
After a comma, the cursor will blink only once, or not at all if this parameter is zero.

=item B<-c> I<style>, B<--case> I<style>

Case mapping of letters. I<style> can be one of:

=over 4

=item l | lower

All characters are mapped to lowercase.

=item u | upper

All characters are mapped to uppercase.  This is the default.

=item n | normal

No case conversion is done.

=item r | reverse

Uppercase characters are displayed in inverse; lowercase characters are mapped to uppercase.

=item s | underscore

Uppercase characters are underscored; lowercase characters are mapped to uppercase.

=back

=item B<-d> I<delay>, B<--delay> I<delay>

The delay in (fractional) seconds between printing words (default: 0.05)

=item B<--demo>

Use a fixed demo text. No other input will be read.

=item I<filename> [ I<filename ...> ]

Files whose content should be displayed. If none are specified, read from standard input.

=back

=head1 EXAMPLES

=over 4

=item phosphor -d 0.1 --demo

=item phosphor -c s -br 0.2 --demo

=back

=head1 SEE ALSO

For developers: infocmp(1), tput(1), Term::Terminfo(3pm).

=head1 VERSION

=for roff
.PP \" display the 'pertains to'-macro
.Vp \*(Vw

=head1 AUTHOR and COPYRIGHT

=for roff
.\" the \(co macro only exists in groff
.ie \n(.g Copyright \(co \*(Yr, Ren\('e
.el       Copyright (c) \*(Yr, Rene\*'
Uittenbogaard (ruittenb@users.sourceforge.net)

This program is free software; you can redistribute it and/or modify it
under the terms described by the GNU General Public License version 3.

B<phosphor> is distributed without any warranty, even without the
implied warranties of merchantability or fitness for a particular purpose.

=cut

################################################################################
# demo text

__DATA__

There are those who believe that life here began out there, far across the universe.  With tribes of humans who may have been the forefathers of the Egyptians, or the Toltecs, or the Mayans.  That they may have been the architects of the Great Pyramids, or the lost civilizations of Lemuria, or Atlantis.  Some believe that there may yet be brothers of man, who even now fight to survive... somewhere beyond the heavens.

Fleeing from the Cylon tyranny, the last battlestar, Galactica, leads a rag-tag fugitive fleet on a lonely quest: a shining planet, known as Earth.

